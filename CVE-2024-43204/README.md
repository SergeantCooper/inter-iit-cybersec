I was not able to find the exploit for this cve. I just managed to see what the changes were made to the source code to fix the vulnerability. Here's the diff from version 2.4.63 to version 2.4.64 which seems related to the issue:

```
--- a/modules/metadata/mod_headers.c
+++ b/modules/metadata/mod_headers.c
@@ -782,21 +782,27 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
             }
             break;
         case hdr_set:
-            if (!ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                 ap_set_content_type_ex(r, process_tags(hdr, r), 1);
+            if (r->headers_in != headers &&
+                !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                 ap_set_content_type(r, process_tags(hdr, r));
             }
             apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             break;
         case hdr_setifempty:
             if (NULL == apr_table_get(headers, hdr->header)) {
-                if (!ap_cstr_casecmp(hdr->header, "Content-Type")) {
-                    ap_set_content_type_ex(r, process_tags(hdr, r), 1);
+                if (r->headers_in != headers &&
+                    !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                    ap_set_content_type(r, process_tags(hdr, r));
                 }
                 apr_table_setn(headers, hdr->header, process_tags(hdr, r));
             }
             break;
         case hdr_unset:
             apr_table_unset(headers, hdr->header);
+            if (r->headers_in != headers &&
+                !ap_cstr_casecmp(hdr->header, "Content-Type")) {
+                ap_set_content_type(r, NULL);
+            }
             break;
         case hdr_echo:
             v.r = r;
@@ -809,7 +815,7 @@ static int do_headers_fixup(request_rec *r, apr_table_t *headers,
                 const char *repl = process_regexp(hdr, r->content_type, r);
                 if (repl == NULL)
                     return 0;
-                ap_set_content_type_ex(r, repl, 1);
+                if (r->headers_in != headers) ap_set_content_type_ex(r, repl, 1);
             }
             if (apr_table_get(headers, hdr->header)) {
                 edit_do ed;
diff --git a/modules/proxy/mod_proxy_ajp.c b/modules/proxy/mod_proxy_ajp.c
index 32ec9122da..356894ab64 100644
--- a/modules/proxy/mod_proxy_ajp.c
+++ b/modules/proxy/mod_proxy_ajp.c
@@ -218,6 +218,9 @@ static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,
 
     if (psf->io_buffer_size_set)
        maxsize = psf->io_buffer_size;
+    /* Override with worker setting if present */
+    if (conn->worker->s->io_buffer_size_set)
+       maxsize = conn->worker->s->io_buffer_size;
     if (maxsize > AJP_MAX_BUFFER_SZ)
        maxsize = AJP_MAX_BUFFER_SZ;
     else if (maxsize < AJP_MSG_BUFFER_SZ)
diff --git a/modules/proxy/mod_proxy_balancer.c b/modules/proxy/mod_proxy_balancer.c
index 140366e6d5..daec21ad6c 100644
--- a/modules/proxy/mod_proxy_balancer.c
+++ b/modules/proxy/mod_proxy_balancer.c
@@ -276,11 +276,23 @@ static proxy_worker *find_session_route(proxy_balancer *balancer,
                                         char **url)
 {
     proxy_worker *worker = NULL;
+    char *url_with_qs;
 
     if (!*balancer->s->sticky)
         return NULL;
+    /*
+     * The route might be contained in the query string and *url is not
+     * supposed to contain the query string. Hence add it temporarily if
+     * present.
+     */
+    if (r->args) {
+        url_with_qs = apr_pstrcat(r->pool, *url, "?", r->args, NULL);
+    }
+    else {
+        url_with_qs = *url;
+    }
     /* Try to find the sticky route inside url */
-    *route = get_path_param(r->pool, *url, balancer->s->sticky_path, balancer->s->scolonsep);
+    *route = get_path_param(r->pool, url_with_qs, balancer->s->sticky_path, balancer->s->scolonsep);
     if (*route) {
         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01159)
                      "Found value %s for stickysession %s",
```
